## Think in Java

### 基础知识

1. 实现并发最直接的方式是在操作系统中使用进程。

2. Java的线程是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。

3. 线程的调度机制是非确定性的。

4. `Executor`在客户端和任务执行之间提供一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。`Executor`允许你管理异步任务的执行，而不需显式地管理线程的生命周期。

5. `Runnable`是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那可以`Callable`接口而不是`Runnable`接口。

6. 异常不能跨线程传播会`main（）`，所以必须在本地处理所有在任务内部产生的异常。

7. 线程的优先级将该线程的重要性传递给了调度器。但优先级不是绝对，只是处理器优先处理优先级高的线程，因为优先级不会导致死锁。绝大数时间，线程应该以默认的优先级运行，试图修改通常是一种错误。

8. 优先级是在线程`run()`的开头部分设定的，构造器中设置不会有任何好处。

9. 后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此当所有非后台线程运行完，这个程序也就终止了，同时杀死所有的后台线程。调用`setDeaemon()`设置为后台线程。

10. 线程的`start()`不应该放在构造器中，因为另外的一个任务很有可能在构造器结束之前开始调用。

11. 一个线程可以在其他线程之上调用`join（）`方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程`t`上调用`t.join()`，此线程将被挂起，知道目标线程`t`结束才恢复。

    也可以在调用`join`加上一个超时参数，如果到期还没有结束，`join（）`方法总能返回。

    `join（）`方法调用时也可以中断，做法是在调用线程上调用`interrupt方法`。

### 解决共享资源竞争

#### synchorized

1. 基本上所有的并发模式在解决线程冲突问题的时候，都是采取序列化访问共享资源的方案。这就意外着在给定时刻只允许一个任务访问共享资源。这种机制常常被称为互斥量。
2. java以提供关键`synchronized`的形式，为防止资源冲突提供了内置支持。当任务要执行被`synchronized`关键字保护的代码片段时，它将检查锁是否可用，然后获取锁，执行代码，释放锁。
3. 对于某个特定对象来说，其所有`synchronized`方法共享一个锁，这可以被用来防止多个任务同时访问被编码成对象内存。
4. 在使用并发的时候，将域设置为`private`是非常重要的，否则，`synchronized`关键字就不能防止其他任务直接访问域，这样就会产生冲突。
5. 一个任务可以多次获得锁。
6. 针对每个类，也有一个锁（作为类的Class对象的一部分），所以`synchronized static`方法可以在类的范围内防止对`static`数据的并发访问。
7. 如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一个已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。
8. 每个访问临界共享资源的方法都必须被同步，否则他们就不会正确地工作。

#### lock

1. `lock`对象必须被显示地创建，锁定和释放。因此同内建的锁形式相比，代码缺乏优雅性。但是对于解决某些类型的问题来说，它更加灵活。
2. 在使用`sychronized`关键字时，某些事物失败了，那么就会抛出一个异常。但是你没有机会去做任何清理工作，以维护系统使其处于良好状态。
3. 用`sychronized`不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它，要实现这些，你必须使用`concurrent`类库。
4. 显式的`lock`对象在加锁和释放锁方面，相较于内建的`sychronized`来说，赋予了更细粒度的控制力。这对于实现专有同步结构是很有用的，例如在遍历链接列表中的节点的节节传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁。
5. 原子性可以应用于除`long`和`double`之外的所有基本类型之上的“简单操作”。JVM可以将64位（`long`和`double`变量）的读取和写入当作俩个分离的32位操作来执行，这就产生了一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果的可能性。当在定义俩个变量的时候，如果使用`volatile`就会获得（简单的赋值与返回操作的）原子性。但是你不应该依赖于平台相关的特性。
6. 原子操作可由线程机制来保证其不可中断，可使用这一点来编写无锁的代码，这些代码不需要同步。但是过于简化的机制，有时候只是看起来安全。
7. `volatile`确保了应用中的可视性。如果你将一个域声明为`volatile`的，那么只要对这个域有了写操作，那么所有的读操作都可以看到这个修改。即便使用了本地缓存，情况也确实如此。`volatile`会被立即写入到主存中，而读取操作就发生在主存中。
8. 如果多个任务同时访问某个域，那么这个域就应该是`volatile`的，否则这个域就只能经由同步来访问。同步也会导致在主存中刷新，因此如果一个域完全有`synchronized`方法或语句块来维护，那么就不必将其设置为是`valatile`的。一个任务任何读写操作都是可视，如果只是在任务内部可视，也不必设置。
9. 如果域的值依赖于前面的值，或者这个域受到其他域的限制，`valatile`无法使用。
10. 使用`volatile`而不是使用`sychronized`的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用`sychronized`关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。

####  在其他对象上同步

1. `sychronized`块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：`sychronized(this)`。

2. 有时候必须在另一个对象上同步，就必须确保所有相关的任务都是在同一个对象上同步的。

#### 线程本地存储

1. 防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。
2. 创建和管理线程本地存储可以由`ThreadLocal`类来实现。

#### 终止任务

