### 线程

## Think in Java

1. 实现并发最直接的方式是在操作系统中使用进程。

2. Java的线程是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。

3. 线程的调度机制是非确定性的。

4. `Executor`在客户端和任务执行之间提供一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。`Executor`允许你管理异步任务的执行，而不需显式地管理线程的生命周期。

5. `Runnable`是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那可以`Callable`接口而不是`Runnable`接口。

6. 异常不能跨线程传播会main（），所以必须在本地处理所有在任务内部产生的异常。

7. 线程的优先级将该线程的重要性传递给了调度器。但优先级不是绝对，只是处理器优先处理优先级高的线程，因为优先级不会导致死锁。绝大数时间，线程应该以默认的优先级运行，试图修改通常是一种错误。

8. 优先级是在线程`run()`的开头部分设定的，构造器中设置不会有任何好处。

9. 后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此当所有非后台线程运行完，这个程序也就终止了，同时杀死所有的后台线程。调用`setDeaemon()`设置为后台线程。

10. 线程的`start()`不应该放在构造器中，因为另外的一个任务很有可能在构造器结束之前开始调用。

11. 一个线程可以在其他线程之上调用`join（）`方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程`t`上调用`t.join()`，此线程将被挂起，知道目标线程`t`结束才恢复。

    也可以在调用`join`加上一个超时参数，如果到期还没有结束，`join（）`方法总能返回。

    `join（）`方法调用时也可以中断，做法是在调用线程上调用`interrupt方法`。

12.  
