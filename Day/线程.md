## Think in Java

### 基础知识

1. 实现并发最直接的方式是在操作系统中使用进程。

2. Java的线程是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。

3. 线程的调度机制是非确定性的。

4. `Executor`在客户端和任务执行之间提供一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。`Executor`允许你管理异步任务的执行，而不需显式地管理线程的生命周期。

5. `Runnable`是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那可以`Callable`接口而不是`Runnable`接口。

6. 异常不能跨线程传播会`main（）`，所以必须在本地处理所有在任务内部产生的异常。

7. 线程的优先级将该线程的重要性传递给了调度器。但优先级不是绝对，只是处理器优先处理优先级高的线程，因为优先级不会导致死锁。绝大数时间，线程应该以默认的优先级运行，试图修改通常是一种错误。

8. 优先级是在线程`run()`的开头部分设定的，构造器中设置不会有任何好处。

9. 后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此当所有非后台线程运行完，这个程序也就终止了，同时杀死所有的后台线程。调用`setDeaemon()`设置为后台线程。

10. 线程的`start()`不应该放在构造器中，因为另外的一个任务很有可能在构造器结束之前开始调用。

11. 一个线程可以在其他线程之上调用`join（）`方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程`t`上调用`t.join()`，此线程将被挂起，知道目标线程`t`结束才恢复。

    也可以在调用`join`加上一个超时参数，如果到期还没有结束，`join（）`方法总能返回。

    `join（）`方法调用时也可以中断，做法是在调用线程上调用`interrupt方法`。

### 解决共享资源竞争

1. 基本上所有的并发模式在解决线程冲突问题的时候，都是采取序列化访问共享资源的方案。这就意外着在给定时刻只允许一个任务访问共享资源。这种机制常常被称为互斥量。
2. java以提供关键`synchronized`的形式，为防止资源冲突提供了内置支持。当任务要执行被`synchronized`关键字保护的代码片段时，它将检查锁是否可用，然后获取锁，执行代码，释放锁。
3. 对于某个特定对象来说，其所有`synchronized`方法共享一个锁，这可以被用来防止多个任务同时访问被编码成对象内存。
4. 在使用并发的时候，将域设置为`private`是非常重要的，否则，`synchronized`关键字就不能防止其他任务直接访问域，这样就会产生冲突。
5. 一个任务可以多次获得锁。
6. 针对每个类，也有一个锁（作为类的Class对象的一部分），所以`synchronized static`方法可以在类的范围内防止对`static`数据的并发访问。
7. 如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一个已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。
8. 每个访问临界共享资源的方法都必须被同步，否则他们就不会正确地工作。
