## 链表

1. 链表在内存模型中是不连续的，以节点形式存在。每个节点存在`data`域和`next`域。`data`代表了当前的值，`next`指向了下一个节点。首节点可能存在`head`域。

### 单链表

1. 无法实现自我删除。

### 双向链表

### 环形链表

### 链表和数组区别

##### 两者的区别：

1. 数组静态分配内存，链表动态分配内存。
2. 数组在内存中是连续的，链表是不连续的。
3. 数组利用下标定位，查找的时间复杂度是O(1)，链表通过遍历定位元素，查找的时间复杂度是O(N)。
4. 数组插入和删除需要移动其他元素，时间复杂度是O(N)，链表的插入或删除不需要移动其他元素，时间复杂度是O(1)。

##### 数组的优点

​	随机访问性比较强，可以通过下标进行快速定位。
​    查找速度快

##### 数组的缺点

​	插入和删除的效率低，需要移动其他元素。
​    会造成内存的浪费，因为内存是连续的，所以在申请数组的时候就必须规定七内存的大小，如果不合适，就会造成内存的浪费。
​    内存空间要求高，创建一个数组，必须要有足够的连续内存空间。
​    数组的大小是固定的，在创建数组的时候就已经规定好，不能动态拓展。

##### 链表的优点

   插入和删除的效率高，只需要改变指针的指向就可以进行插入和删除。
    内存利用率高，不会浪费内存，可以使用内存中细小的不连续的空间，只有在需要的时候才去创建空间。大小不固定，拓展很灵活。

##### 链表的缺点

​	查找的效率低，因为链表是从第一个节点向后遍历查找。

##### 双链表相对于单链表的优点

​		删除单链表中的某个节点时，一定要得到待删除节点的前驱，得到其前驱的方法一般是在定位待删除节点的时候一路保存当前节点的前驱，这样指针的总的的移动操作为2n次，如果是用双链表，就不需要去定位前驱，所以指针的总的的移动操作为n次。
  查找时也是一样的，可以用二分法的思路，从头节点向后和尾节点向前同时进行，这样效率也可以提高一倍，但是为什么市场上对于单链表的使用要超过双链表呢？从存储结构来看，每一个双链表的节点都比单链表的节点多一个指针，如果长度是n，就需要n*lenght（32位是4字节，64位是8字节）的空间，这在一些追求时间效率不高的应用下就不适用了，因为他占的空间大于单链表的1/3，所以设计者就会一时间换空间。

#### 链表环问题

###### 判断是否有环

​		定义一个快指针和一个慢指针，快指针一次走两步，慢指针一次走两步，会出现两种情况，情况一指针走到了空的位置，那就说明这个链表不带环。情况二两个指针相遇，说明这个链表带环。

###### 获得入环节点

​		如果不考虑空间复杂度，可以使用一个map来记录走过的节点，这个指针一直向后遍历如果遇到空，说明这个链表不带环，也就没有入环节点，如果没有遇到空，如果遇到第一个在map中存在的节点，就说明回到了出发点，这个节点就是环的入口节点。如果不建立额外的空间，先使用快慢指针判断这个链表是否有环，如果有环将相遇节点记录，然后一个指针从链表的起始位置开始一次走一步，另一个指针从记录的节点开始一次走一步，当两个节点再次相遇，这个相遇节点就是环的入口节点。

## 栈

1. 先进后出，栈底与栈顶的特性。



参考文章

------

https://blog.csdn.net/Shuffle_Ts/article/details/95055467  链表