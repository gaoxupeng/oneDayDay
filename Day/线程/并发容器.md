简易介绍 https://blog.csdn.net/qq_34173549/article/details/79612522

### CopyOnWriteArrayList

- `copyOnWriteArrayList`是一个线程安全的`arrayList`

- `copyOnWriteSet`是线程安全的`set`，内部包含了一个`copyOnWriteArrayList`，因此本质上是由`copyOnWriteArrayList`实现的。

  ##### 特性

- 适用于读操作远远多于写操作，并且数据量较小的情况。
- 修改容器的代码是非常昂贵的，因此建议批量`addAll`和`removeAll`

  ##### 如何实现线程安全

1. 使用`volatile修饰数组引用`，确保数据引用的可见性。
2. 对容器修改操作进行同步时，确保同一时刻只有一条线程修改容器（因为修改容器都会产生一个新的容器，增加同步可避免同一时刻复制生成多个容器，从而无法保证数组数据的一致性）
3. 修改时复制容器，确保所有修改操作都作用在新数组上，原本的数组在创建过后就不再使用，从而其他线程放心读。

   #####  迭代

- `copyOnWriteArrayList`拥有内部类：`COWIterator`，他是`ListIterator`的子类。

- 当调用`Iterator`返回的是`COWIterator`对象。

- `COWIterator`不允许修改容器，修改则会抛出异常。

  ##### 优点

- 读操作无需加锁，从而高效。

  ##### 缺点
  ###### 	数据一致性问题
	  - 由于迭代的是容器当前的快照，因此在迭代过程中容器发生的修改并不能实时被当前正在迭代的线程感知。
  ###### 	内存占用问题
	  - 由于修改容器都会复制数组，从而当数组超大时修改容器效率很低
	  - 因此写时复制容器适合存储小容量数据。

##### 源码

1. 添加方法，删除方法思想类似。具体源码请看`JDK`

   ```java
   public boolean add(E e) {
       final ReentrantLock lock = this.lock;
       lock.lock();
       try {
           Object[] elements = getArray();
           int len = elements.length;
           Object[] newElements = Arrays.copyOf(elements, len + 1); // 原有数组长度+1，复制一个新数组，返回新的数组
           newElements[len] = e;
           setArray(newElements);
           return true;
       } finally {
           lock.unlock();
       }
   }
   ```

 ```java
   public void add(int index, E element) { //指定位置添加
       final ReentrantLock lock = this.lock;
       lock.lock();
       try {
           Object[] elements = getArray();
           int len = elements.length;
           if (index > len || index < 0) //越界抛异常
               throw new IndexOutOfBoundsException("Index: "+index+
                                                   ", Size: "+len);
           Object[] newElements;   
           int numMoved = len - index;
           if (numMoved == 0)
               newElements = Arrays.copyOf(elements, len + 1);  
           else {  //指定位置的前面数组复制一份，后面数组复制一份，然后三个整合输出新数组
               newElements = new Object[len + 1];
               System.arraycopy(elements, 0, newElements, 0, index);
               System.arraycopy(elements, index, newElements, index + 1,
                                numMoved);
           }
           newElements[index] = element;
           setArray(newElements);
       } finally {
           lock.unlock();
       }
   }
 ```

2. `copyOnWriteSet`实际是`copyOnWriteArrayList`

   ```java
   public CopyOnWriteArraySet(Collection<? extends E> c) {
       if (c.getClass() == CopyOnWriteArraySet.class) {
           @SuppressWarnings("unchecked") CopyOnWriteArraySet<E> cc =
               (CopyOnWriteArraySet<E>)c;
           al = new CopyOnWriteArrayList<E>(cc.al);
       }
       else {
           al = new CopyOnWriteArrayList<E>();
           al.addAllAbsent(c);
       }
   }
   ```

### ConcurrentHashMap

https://my.oschina.net/u/4108008/blog/3033853 参考博客

1. 一次添加操作整体流程：

   - 如果桶数组未初始化，则初始化；

   - 如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置

   - 如果正在扩容，则当前线程一起加入到扩容的过程中

   - 如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）

   - 如果当前桶中元素以链表方式存储，则在链表中寻找元素或者插入元素

   - 如果桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素

   - 如果元素存在，则返回旧值

   - 如果元素不存在，整个`Map`的元素个数加1，并检查是否需要扩容

     添加元素操作中的使用的锁主要有（自旋锁+CAS+Sychronized+分段锁）

     ```java
     public V put(K key, V value) {
         return putVal(key, value, false);
     }
     
     final V putVal(K key, V value, boolean onlyIfAbsent) {
         // key和value都不能为null
         if (key == null || value == null) throw new NullPointerException();
         // 计算hash值
         int hash = spread(key.hashCode());
         // 要插入的元素所在桶的元素个数
         int binCount = 0;
         // 死循环，结合CAS使用（如果CAS失败，则会重新取整个桶进行下面的流程）
         for (Node<K,V>[] tab = table;;) {
             Node<K,V> f; int n, i, fh;
             if (tab == null || (n = tab.length) == 0)
                 // 如果桶未初始化或者桶个数为0，则初始化桶
                 tab = initTable();
             else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                 // 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中
                 if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                     // 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作
                     // 如果使用CAS插入元素成功，则break跳出循环，流程结束
                     break;                   // no lock when adding to empty bin
             }
             else if ((fh = f.hash) == MOVED)
                 // 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素
                 tab = helpTransfer(tab, f);
             else {
                 // 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁）
                 // 并查找要插入的元素是否在这个桶中
                 // 存在，则替换值（onlyIfAbsent=false）
                 // 不存在，则插入到链表结尾或插入树中
                 V oldVal = null;
                 synchronized (f) {
                     // 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过
                     if (tabAt(tab, i) == f) {
                         // 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树）
                         // 那就是桶中的元素使用的是链表方式存储
                         if (fh >= 0) {
                             // 桶中元素个数赋值为1
                             binCount = 1;
                             // 遍历整个桶，每次结束binCount加1
                             for (Node<K,V> e = f;; ++binCount) {
                                 K ek;
                                 if (e.hash == hash &&
                                         ((ek = e.key) == key ||
                                                 (ek != null && key.equals(ek)))) {
                                     // 如果找到了这个元素，则赋值了新值（onlyIfAbsent=false）
                                     // 并退出循环
                                     oldVal = e.val;
                                     if (!onlyIfAbsent)
                                         e.val = value;
                                     break;
                                 }
                                 Node<K,V> pred = e;
                                 if ((e = e.next) == null) {
                                     // 如果到链表尾部还没有找到元素
                                     // 就把它插入到链表结尾并退出循环
                                     pred.next = new Node<K,V>(hash, key,
                                             value, null);
                                     break;
                                 }
                             }
                         }
                         else if (f instanceof TreeBin) {
                             // 如果第一个元素是树节点
                             Node<K,V> p;
                             // 桶中元素个数赋值为2
                             binCount = 2;
                             // 调用红黑树的插入方法插入元素
                             // 如果成功插入则返回null
                             // 否则返回寻找到的节点
                             if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                     value)) != null) {
                                 // 如果找到了这个元素，则赋值了新值（onlyIfAbsent=false）
                                 // 并退出循环
                                 oldVal = p.val;
                                 if (!onlyIfAbsent)
                                     p.val = value;
                             }
                         }
                     }
                 }
                 // 如果binCount不为0，说明成功插入了元素或者寻找到了元素
                 if (binCount != 0) {
                     // 如果链表元素个数达到了8，则尝试树化
                     // 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数
                     // 所以不会重复树化
                     if (binCount >= TREEIFY_THRESHOLD)
                         treeifyBin(tab, i);
                     // 如果要插入的元素已经存在，则返回旧值
                     if (oldVal != null)
                         return oldVal;
                     // 退出外层大循环，流程结束
                     break;
                 }
             }
             }
             // 成功插入元素，元素个数加1（是否要扩容在这个里面）
             addCount(1L, binCount);
             // 成功插入元素返回null
             return null;
         }
     ```

### ConcurrentSkipListMap

### ConcurrentSkipListSet

### Queue

#### ArrayBlockingQueue

#### LinkedBlockingQueue

#### LinkedBlockingDeque

#### ConcurrentLinkedQueue



